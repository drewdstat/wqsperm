---
title: "How to use the wqsperm package"
author: "Drew Day, James Peng"
date: "2/18/2022"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction 

Weighted quantile sum (WQS) regression is a statistical technique to evaluate the 
effect of complex exposure mixtures on an outcome (Carrico et al. 2015). It is a 
single-index method which estimates a combined mixture sum effect as well as weights 
determining each individual mixture component's contributions to the sum effect. 
However, the model features a statistical power and Type I error (i.e., false positive) 
rate tradeoff, as there is a machine learning step to determine the weights that 
optimize the linear model fit. If the full data is used to estimate both the mixture 
component weights and the regression coefficients, there is high power but also a 
high false positive rate since coefficient p-values are calculated for a weighted 
mixture independent variable calculated using weights that have already been optimized 
to find a large effect. 

We recently proposed an alternative method based on a permutation test that should 
reliably allow for both high power and low false positive rate when utilizing WQS.
The permutation test is a method of obtaining a p-value by simulating the null 
distribution through permutations of the data. The permutation test algorithm 
is described more in detail in (reference Drew's paper).

## About WQS 

The goal of WQS regression is to determine whether an exposure mixture is associated 
with an outcome in a prespecified direction. It fits the following model: 

$Y = \beta_0 + \beta_1(\sum_{i=1}^{c} w_i {X_q}_i) + z'\gamma$   

Where $Y$ is the outcome variable, $\beta_0$ is the intercept, $\beta_1$ is the 
coefficient for the weighted quantile sum, $\sum_{i=1}^{c} w_i {X_q}_i$ is the 
weighted index for the setof quantiled mixture exposures, $z$ is the set of 
covariates, and $\gamma$ is the regression coefficients for the covariates. 

A full description of the WQS methodology is described in (Carrico, 2015). 

## Permutation Test 

The WQS regression comprises of two steps, for which we typically split the data 
into a training and validation set. Doing this reduces statistical power since 
we are training our model on only part of the data. On the other hand, if we skip this 
training/test split, we can get a skewed representation of uncertainty for the WQS 
coefficient. The following permutation method gives us a p-value for the uncertainty while also
allowing us to use the full dataset for training and validation. It works as follows:

1. Run WQS regression without splitting the data, obtaining a WQS coefficient estimate. 

2. Regress the outcome on all covariates but not the WQS variable. Then obtain the 
predicted outcome values and their residuals from this regression. 

3. Randomly permute the residual values and add them to the predicted outcome values
to get a new outcome variable $y*$. 

4. Run a WQS regression without splitting the data in which $y*$ replaces the vector of 
observed outcome variables, obtaining an estimate for the WQS coefficient $\beta_1^*$. 

5. Repeat steps 3 and 4. 

6. Calculate the p-value by taking the proportion of $\beta_1^*$ values greater than 
the WQS coefficient estimate obtained in Step 1. 

# How to use the `wqsperm` package 

The `wqsperm` package builds from the `gWQS` package.

The two main functions of the `wqsPerm` package are `wqs_perm` and `wqs_full_perm`. 

## `wqs_perm`

`wqs_perm` uses a `gwqs` object (from the `gWQS` package) as an input. To use `wqs_perm`, 
we first need to run an initial *WQS regression* while setting `validation=0`.  

We will use this `gwqs` object as the `model` argument for the `wqs_perm` 
function and set the following additional parameters: 

* `boots`: Number of bootstraps for the WQS run in each permutation test iteration. 
Note that we may elect a bootstrap count `boots` lower than that specified in the 
`model` object for the sake of efficiency. If we do, `wqs_perm` will generate a 
permutation test reference WQS run with that number of bootstraps to determine 
the reference $\beta_1$ value. If `boots` is not specified, then we will use the
same bootstrap count in the permutation test WQS runs as that specified in the 
main WQS run.
* `niter`: Number of permutation test iterations 
* `b1_pos`: A logical value that indicates whether beta values should be positive 
or negative
* `rs`: A logical value indicating whether the random subset implementation for WQS 
should be performed
* `plan_strategy`: Evaluation strategy for the plan function. You can choose among 
"sequential", "transparent", "multisession", "multicore", "multiprocess", "cluster" 
and "remote." See gWQS package documentation for full details.  
* `seed`: Random seed for the permutation test WQS reference run

The arguments `b1_pos` and `rs` should be consistent with the inputs chosen in 
the `model` object. The `seed` should ideally be consistent with the seed set 
in the `model` object, though this is not required. 

The permutation test returns an object of class `wqs_perm`, which contains three 
sublists: 

* `perm_test`
  * `pval`: p-value for the proportion of permuted WQS coefficient values greater 
  than the reference value
  * `testbeta`: reference WQS coefficient $\beta_1$ value 
  * `betas`: a vector of $\beta_1$ values from each iteration of the permutation test
* `gwqs_main`: main gWQS object (same as `model` input)
* `gwqs_perm`: permutation test reference gWQS object (NULL if same number of bootstraps)

The `wqs_perm` class has a plotting method to help visualize and summarize WQS 
permutation test results. Plots include (1) a forest plot of the beta WQS coefficient 
with the naive confidence intervals as well as the permutation test p-value and
(2) a heatmap of the WQS weights for each mixture component. 

## `wqs_full_perm` 

The second function `wqs_full_perm` is a full wrapper which implements the initial 
gWQS run and permutation test in one function call. 

To use `wqs_full_perm`, you must specify the same required arguments as needed in 
the `gwqs` call. For the bootstrap count `b` argument, you must specify `b_main`, 
the number of bootstraps for the *main WQS regression* run and `b_perm`, the number 
of bootstraps for the *permutation test reference WQS regression* run. As with before, 
it is acceptable/standard for `b_main` $>$ `b_perm` for the sake of efficiency. 
Finally, you should indicate the number of desired permutation test runs `niter`.

The `wqs_full_perm` returns an object of class `wqs_perm`, with outputs described above. 

## Recommendations for use 

We recommend that users only apply the permutation test in cases where the naive 
WQS test approaches significance or near-significance. If the naive test produces 
a non-significant result, then there likely is no reason to run the permutation test, as it will produce a 
result which is more conservative than the naive method. This is the strategy that we have applied 
in our published papers (Loftus 2021 and Day 2021). 

## Limitations 

Note that there are limitations in the current version of the WQS permutation test 
algorithm and package implementation:

* **Linear regression only:** The permutation test algorithm can only have `gwqs` 
inputs where `family = gaussian` and `link = identity`. A logistic regression version 
for the algorithm is currently in the works. 
* **Interaction terms or stratified weights:**  This permutation test is not yet 
set up to accommodate stratified weights or WQS interaction terms.

# Examples 

## Example 1 (using `wqs_perm`)

This is an example where the WQS permutation test confirms a significant naive result.

We first produce a simulated dataset with the following parameters: 

* WQS coefficient $\beta_1$: 0.3 
* Mixture weights: 0.15 for first 5 components, 0.05 for remaining  5 components 

```{r, warning = F, message = F}
library(gWQS)
library(wqsperm)

# simulated dataset
sim_res1 <- wqs_sim(nmix = 10,
                    ncovrt = 10,
                    nobs = 1000,
                    ntruewts = 10, 
                    ntruecovrt = 5, 
                    truewqsbeta = 0.3, 
                    truebeta0 = 2, 
                    truewts = c(0.15, 0.15, 0.15, 0.15, 0.15,
                                0.05, 0.05, 0.05, 0.05, 0.05), 
                    q = 10)

sim_data1 <- sim_res1$Data
```

Now we run WQS regression on the simulated data.  

```{r}
# mixture names
mix_names1 <- colnames(sim_data1)[2:11]

# TODO: Change bootstrap/iteration counts to be more realistic

# create reference wqs object
wqs_main1 <- gwqs(y ~ wqs, mix_name = mix_names1, data = sim_data1, q = 10, validation = 0,
                b = 10, b1_pos = T, plan_strategy = "multicore", family = "gaussian", 
                seed = 16)
```

Finally, we can perform a permutation test on the WQS object. 

```{r}
# run permutation test
perm_test_res1 <- wqs_perm(wqs_main1, niter = 10, boots = 5, b1_pos = T)
```

Note that the naive WQS regression produces a significant result for the 
WQS coefficient (p-value < 0.001).

```{r}
main_sum1 <- summary(perm_test_res1$gwqs_main)

main_sum1$coefficients
```

The permutation test confirms the significance of this result. 

```{r}
perm_test_res1$perm_test$pval
```

Here are the summary plots: 

```{r, fig.height = 6}
plot(perm_test_res1)$FullPlot
```


## Example 2

This is an example where the WQS permutation test goes against a (false positive) 
significant naive result. 

We produce a simulated dataset with the following parameters: 

* WQS coefficient $\beta_1$: 0
* Mixture weights: 0.15 for first 5 components, 0.05 for remaining  5 components 

```{r, warning = F, message = F}
library(gWQS)
library(wqsperm)

# simulated dataset
sim_res2 <- wqs_sim(nmix = 10,
                    ncovrt = 10,
                    nobs = 1000,
                    ntruewts = 10, 
                    ntruecovrt = 5, 
                    truewqsbeta = 0, 
                    truebeta0 = 0.1, 
                    truewts = c(0.15, 0.15, 0.15, 0.15, 0.15,
                                0.05, 0.05, 0.05, 0.05, 0.05), 
                    q = 10)

sim_data2 <- sim_res2$Data
```

Now we run WQS regression as well as the permutation test on the simulated data.  

```{r}
# mixture names
mix_names2 <- colnames(sim_data2)[2:11]

# TODO: Change bootstrap/iteration counts to be more realistic

# create reference wqs object
wqs_main2 <- gwqs(y ~ wqs, mix_name = mix_names2, data = sim_data2, q = 10, validation = 0,
                b = 10, b1_pos = T, plan_strategy = "multicore", family = "gaussian", 
                seed = 16)

# run permutation test
perm_test_res2 <- wqs_perm(wqs_main2, niter = 10, boots = 5, b1_pos = T)
```

Note that the naive WQS regression produces a significant result for the 
WQS coefficient (p-value = 0.049).

```{r}
main_sum2 <- summary(perm_test_res2$gwqs_main)

main_sum2$coefficients
```

The permutation test, however, repudiates the signficance of these plots (p = 0.43).  

```{r}
perm_test_res2$perm_test$pval
```

Here are the summary plots: 

```{r, fig.height = 6}
plot(perm_test_res2)$FullPlot
```

## Example 3 (using `wqs_full_perm`)

Using the same data as in Example 1, we run the WQS regression with permutation test
using the full wrapper `wqs_full_perm` call. 

```{r, fig.height = 6}
perm_test_res <- wqs_full_perm(y ~ wqs,
                               data = sim_data1,
                               mix_name = mix_names1,
                               q = 10,
                               b_main = 10,
                               b_perm = 5,
                               b1_pos = T,
                               niter = 10,
                               seed = 16,
                               plan_strategy = "multicore",
                               returnbetas = TRUE)

plot(perm_test_res)$FullPlot
```

